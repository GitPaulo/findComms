{"ast":null,"code":"import { EventEmitter, Directive, ElementRef, Output, Input, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { fromEvent } from 'rxjs';\nimport { debounceTime, map, distinctUntilChanged, filter } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nlet InputSearchDirective = /*#__PURE__*/(() => {\n  class InputSearchDirective {\n    /**\n     * @param {?} el\n     */\n    constructor(el) {\n      this.el = el;\n      this.debounceTimeDefault = 400;\n      this.minStringLengthDefault = 0; // Set defaults\n\n      this.debounceTime = this.debounceTimeDefault;\n      this.stringLength = this.minStringLengthDefault;\n      this.ngxInputSearch = new EventEmitter();\n      this.stringTooShort = new EventEmitter();\n      this.emptyInput = new EventEmitter();\n      this.inputEl = this.el.nativeElement;\n    }\n    /**\n     * Indicates how much time in ms we will wait for the users stops typing.\n     * By default is 400ms\n     * @param {?} dbTime\n     * @return {?}\n     */\n\n\n    set debounceTime(dbTime) {\n      this._debounceTime = dbTime ? dbTime : this.debounceTimeDefault;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get debounceTime() {\n      return this._debounceTime;\n    }\n    /**\n     * Indicates the minimum length that must have the string to be emitted.\n     * By default is 0\n     * @param {?} stLength\n     * @return {?}\n     */\n\n\n    set stringLength(stLength) {\n      this._stringLength = stLength && stLength >= 0 ? stLength : this.minStringLengthDefault;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get stringLength() {\n      return this._stringLength;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      // Subscribe to the input event\n      this.inputEventSubs = fromEvent(this.inputEl, 'input').pipe( // Wait until the user stops writing\n      debounceTime(this.debounceTime), // Transform the event to track the input value, to use it in the comparison\n      map(\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => ({\n        value:\n        /** @type {?} */\n        event.target.value.trim(),\n        event\n      })), // Avoid emitting of the input value is the same\n      distinctUntilChanged(\n      /**\n      * @param {?} prev\n      * @param {?} next\n      * @return {?}\n      */\n      (prev, next) => prev.value === next.value), // Validate the minimum length that must have the string\n      filter(\n      /**\n      * @param {?} tmpObj\n      * @return {?}\n      */\n      tmpObj => {\n        if (tmpObj.value.length === 0) {\n          // emit that the input is empty\n          this.emptyInput.emit();\n          return false;\n        }\n\n        if (tmpObj.value.length < this.stringLength) {\n          // emit that the string length is too short\n          this.stringTooShort.emit(tmpObj.value);\n          return false;\n        } else {\n          return true;\n        }\n      }), // Return only the input event\n      map(\n      /**\n      * @param {?} tmpObj\n      * @return {?}\n      */\n      tmpObj => tmpObj.event)).subscribe(\n      /**\n      * @param {?} $event\n      * @return {?}\n      */\n      $event => this.ngxInputSearch.next($event));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.inputEventSubs.unsubscribe();\n    }\n\n  }\n\n  InputSearchDirective.ɵfac = function InputSearchDirective_Factory(t) {\n    return new (t || InputSearchDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  InputSearchDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: InputSearchDirective,\n    selectors: [[\"\", \"ngxInputSearch\", \"\"]],\n    inputs: {\n      debounceTime: \"debounceTime\",\n      stringLength: \"stringLength\"\n    },\n    outputs: {\n      ngxInputSearch: \"ngxInputSearch\",\n      stringTooShort: \"stringTooShort\",\n      emptyInput: \"emptyInput\"\n    }\n  });\n  /** @nocollapse */\n\n  return InputSearchDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  InputSearchDirective.prototype.debounceTimeDefault;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InputSearchDirective.prototype.minStringLengthDefault;\n  /**\n   * The output to indicate when the user finish to type on the\n   * input search\n   * @type {?}\n   */\n\n  InputSearchDirective.prototype.ngxInputSearch;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InputSearchDirective.prototype._debounceTime;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InputSearchDirective.prototype._stringLength;\n  /**\n   * Indicates when the string written length is shorter than the minimum\n   * defined by the property `stringLength`\n   * @type {?}\n   */\n\n  InputSearchDirective.prototype.stringTooShort;\n  /**\n   * Indicates when the input is empty\n   * @type {?}\n   */\n\n  InputSearchDirective.prototype.emptyInput;\n  /**\n   * The native element instance of the input\n   * @type {?}\n   * @private\n   */\n\n  InputSearchDirective.prototype.inputEl;\n  /**\n   * The subscription to the input native event.\n   * Useful to unsubscribe when is destroyed to avoid memory leaks\n   * @type {?}\n   * @private\n   */\n\n  InputSearchDirective.prototype.inputEventSubs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  InputSearchDirective.prototype.el;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet NgxInputSearchModule = /*#__PURE__*/(() => {\n  class NgxInputSearchModule {}\n\n  NgxInputSearchModule.ɵfac = function NgxInputSearchModule_Factory(t) {\n    return new (t || NgxInputSearchModule)();\n  };\n\n  NgxInputSearchModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxInputSearchModule\n  });\n  NgxInputSearchModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return NgxInputSearchModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxInputSearchModule, {\n    declarations: function () {\n      return [InputSearchDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [InputSearchDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { NgxInputSearchModule, InputSearchDirective as ɵa }; //# sourceMappingURL=ngx-input-search.js.map","map":null,"metadata":{},"sourceType":"module"}